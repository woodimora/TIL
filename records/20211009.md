# 1. 테스트 코드 작성시 장/단점
## 1.1. 장/단점

### 장점

1. 클린 코드
    - 코드의 재사용성을 보장할 것을 명시하므로 철저한 모듈화가 이루어진다.
    - 필요에 따라 모듈을 추가하거나 제거해도 소프트웨어 전체 구조에 영향을 미치지 않게된다.
2. 시간의 단축 
    - 추가 기능 구현 시 기존 코드에 대한 영향을 확인 할 수 있다.
    - 반복적인 테스트 과정을 단축 시켜준다.
3. 설명서의 역할을 대신해준다. 
    - 테스트 코드를 통해서 처음 코드를 보는 개발자들이 코드 동작을 쉽게 확인 할 수 있다.

### 단점

 1. 생산성 저하

- 일정이 다급한 단발성 개발 기간을 가진 단순한 애플리케이션에도 테스트 코드에 시간을 할애하게 된다.
- 어려운 예외가 발생하게 되면 테스트 코드에 작성에 많은 할애하게 되어 진행을 못하게 되는 경우가 생긴다.

## 1.2. 단위 테스트

응용 프로그램에서 테스트 가능한 가장 작은 소프트웨어를 실행하여 예상대로 동작하는지 확인하는 테스트.

일반적으로 클래스 또는 메소드 수준. 단위 테스트를 최대한 간단하고 디버깅하기 쉽게 작성해야한다.

## 1.3. 통합 테스트

단위 테스트보다 큰 동작을 달성하기 위해 여러 모듈을 모아 이들이 의도한대로 협력하는지 확인하는 테스트.

단위 테스트와 달리 개발자가 변경할 수 없는 부분(ex. 외부라이브러리) 까지 묶어서 검증할 때 사용한다.

DB에 접근하거나 전체 코드와 다양한 환경이 제대로 동작하는지 확인하는데 필요한 모든 작업을 수행하지만 응용 프로그램이 완전하게 작동한다는 것을 증명하지는 않는다. 한번에 많은 코드를 묶어서 테스트 하므로 신뢰성이 떨어지고 어디서 에러가 발생했는지 확인하기 어려워 유지보수하기 힘들다.

## 1.4. E2E 테스트

해당 시스템과 해당 시스템을 구축하고 배포하는 프로세스를 모두 테스트.

EndPoint(종단) 간 테스트로 사용자의 입장에서 사용자가 사용하는 상황을 가정하고 테스트하는 것. 일반적으로 웹이나 어플 등에서 GUI를 통해 시나리오, 기능 테스트 등을 수행한다.

백엔드 관점에서 개발한 REST API를 테스트 하기 위해 실제로 서버에 요청을 보낸 뒤 클라이언트에서 원하는 데이터가 전송되는 지 확인한다.

---

# 2. Spring Data JPA

Spring 에서 JPA를 편리하게 쓰기 편하게 만들어놓은 모듈이다. JPA를 한 단계 더 추상화시킨 Repository라는 `인터페이스`를 제공함으로써 이루어진다.r

<img width="644" alt="Screen Shot 2021-10-09 at 10 03 47 AM" src="https://user-images.githubusercontent.com/70922665/136640046-7cd703dd-8395-40cf-8ece-4ad0c26194e6.png">

출처 https://suhwan.dev/2019/02/24/jpa-vs-hibernate-vs-spring-data-jpa/

- 공통 메서드가 아닐 경우에도 JPA가 메서드 이름을 분석하여 JPQL을 생성한다.
- 개발자는 repository에 인터페이스만 작성해도 개발을 완료할 수 있도록 지원해준다.
- Spring Data JPA가 구현 객체를 동적으로 생성하여 주입해준다.
- CRUD 처리를 위한 공통 인터페이스를 제공한다.

---

# 3. 관점지향 프로그래밍 - AOP (Aspect Oriented Programming)
핵심 기능과 부가기능의 관점, 관심이 다른 것들을 부분적으로 나누어서 모듈화 하는 것이다.
![Untitled (1)](https://user-images.githubusercontent.com/70922665/136640171-e970c326-ebfc-4832-a413-b5f4f0333c08.png)

## 3.1. AOP 특징
### 3.1.1. 프록시 패턴 기반
- Spring은 타겟 객체에 대한 프록시를 만들어서 제공
- 타겟을 감싸는 프록시는 실행시간에 생성
- 프록시는 어드바이스를 타겟 객체에 적용하면서 생성되는 객체
- 프록시 객체를 쓰는 이유는 접근 제어 및 부가기능을 추가하기 위함
### 3.1.2. 프록시가 호출을 가로챔(Intercept)
    - 프록시는 타겟 객체에 대한 호출을 가로챈 다음 어드바이스의 부가기능 로직을 수행하고 난 후에 타겟의 핵심기능 로직을 호출함 ( 전처리 어드바이스 )
    - 타겟의 핵심기능 로직 메서드를 호출한 후에 부가기능(어드바이스)을 수행하는 경우도 있다.(후처리 어드바이스)
### 3.1.3. 메서드 조인 포인트만 지원
    - Spring은 동적 프록시를 기반으로 AOP를 구현하므로 메서드 조인 포인트만 지원
    - **핵심기능(타겟)의 메서드가 호출되는 런타임 시점에만 부가기능(어드바이스)을 적용할 수 있음
    - 반면에 AspectJ같은 고급 AOP 프레임워크를 사용하면 객체의 생성, 필드값의 조회와 조작, static 메서드 호출 및 초기화 등의 다양한 작업에 부가기능을 적용할 수 있음

> * 프록시 패턴 - 어떤 기능을 추가하려 할 때 기존 코드를 변경하지 않고 추가 가능- 어떤 클래스가 String AOP의 대상이라면 그 기존 클래스의 빈이 만들어질 때 Spring AOP가 프록시(기능이 추가된 클래스)를 자동으로 만들고 원본 클래스 대신 프록시 빈으로 등록- 그리고 원본 클래스가 사용되는 지점에서 프록시를 대신 사용
> 

> * 스프링 빈 - Spring IoC 컨테이너가 관리하는 자바 객체를 빈(Bean)이라는 용어로 부름- 우리가 new 연산자로 어떤 객체를 생성했을 대 그 객체는 빈이 아니다.- ApplicationContext.getBean()으로 얻어질 수 있는 객체는 빈이다.- 즉 Spring에서의 빈은 ApplicationContext가 알고 있는 객체, 즉 ApplicationContext가 만들어서 그 안에 담고 있는 객체를 의미
> 

---


## 3.2 장점
- 공통 관심 사항을 핵심 관심사항으로부터 분리시켜 핵심 로직을 깔끔하게 유지할 수 있다.
- 그에 따라 코드의 가독성, 유지보수성 등을 높일 수 있다.
- 각각의 모듈에 수정이 필요하면 다른 모듈의 수정 없이 해당 로직만 변경하면 된다.
- 공통 로직을 적용할 대상을 선택할 수 있다

---


## 3.3 AOP 주요 키워드

- Target
    - 핵심 기능을 담고 있는 모듈
    - 어떤 관심사들과도 관계를 맺지 않음
    - Aspect를 적용하는 곳 ( 클래스, 메서드 )
- Aspect
    - 흩어진 관심사를 모듈화한 것 ( 여러 핵심 기능에 적용될 관심사 모듈 )
    - 구체적인 기능을 구현한 Advice와 Advice가 어디에서 적용될지를 결정하는 PointCut을 포함
    - AOP의 기본 모듈싱글톤 형태의 객체로 존재
- Advice
    - 타겟에 제공할 부가기능을 담고 있는 모듈 ( 실질적인 부가기능을 담은 구현체 )
    - 실질적으로 어떤 일을 해야할 지에 대한 것
    - Aspect가 무엇을 언제 적용할지를 정의
- PointCut
    - 공통 기능이 적용될 대상 결정
    - 어드바이스를 적용할 타겟의 메서드를 선별하는 정규표현식
    - JoinPont의 상세한 스펙을 정의한 것
    - execution으로 시작하고 메서드의 Signature를 비교하는 방법을 주로 이용
- JoinPont
    - Advice가 적용될 위치, 끼어들 수 있는 지점
    - 타겟 객체가 구현한 인터페이스의 모든 메서드는 조인 포인트가 됨
    - 메서드 진입 지점, 생성자 호출 시점, 필드에서 값을 꺼내올 때 등 다양한 시점에 적용 가능
- Advisor
    - Advice + Pointcut
    - Spring AOP에서만 사용되는 용어
- Weaving
    - 포인트컷에 의해서 결정된 타겟의 조인 포인트에 부가기능(어드바이스)를 삽입하는 과정
    - AOP가 핵심기능(타겟)의 코드에 영향을 주지 않으면서 필요한 부가기능(어드바이스)를 추가할 수 있도록 해주는 핵심적인 처리과정