# 프록시 패턴
## 프록시 객체를 사용하는 이유
- SRP(단일 책임 원칙) : 본인이 가진 역할 이외에는 추가가 되면 안된다.
- 하나의 클래스는 하나의 역할만 해야한다. 다른 역할을 하는 것을 추가할 땐 해당 클래스가 수정이 되어선 안된다.
- 로깅 기능을 추가한다던가, 권한 체크 기능을 추가하는 등의 경우에 리얼 서브젝트를 직접 수정해서는 안된다.

## 데코레이션 패턴
- 데코레이션 패턴은 타깃에 부가적인 기능을 런타임 시 다이나믹하게 부여해주기 위해서 프록시를 사용하는 패턴을 말한다.
- 프록시를 여러개 쓸 수 있고 순서를 정해서 단계적으로 위임할 수 있다.
- 데코레이터 패턴은 인터페이스를 통해 위임하는 방식이므로 어느 데코레이터에서 타깃으로 연결될지 코드레벨에선 미리 알 수 없다.
- 타깃의 코드의 손대지 않고, 클라이언트가 호출하는 방법도 변경하지 않은 채로 새로운 기능을 추가할 때 유용하다.

## 프록시 패턴
- 일반적으로 말하는 프록시는 클라이언트와 사용 대상 사이의 대리 역할을 맡은 오브젝트를 두는 방법을 말한다.
- 프록시 패턴의 프록시를 사용하는 방법 중에서 타깃에 대한 접근 방법을 제어하려는 목적을 가진 경우를 말한다.
- 프록시 패턴의 프록시는 타깃의 기능을 확장하거나 추가하지 않는다. 대신 클라이언트가 타깃에 접근하는 방식을 변경해준다.
- 타깃 오브젝트를 필요한 시점까지 생성하지 않고 있다가 타깃 오브젝트에 대한 레퍼런스가 필요하면 프록시 패터늘 적용하면 된다.(지연생성)
- 클라이언트에게 타깃에 대한 레퍼런스를 넘겨야 하는데 실제 타깃 오브젝트 대신 프록시를 넘긴다.
- 해당 타깃을 사용하려 할 때 프록시가 타깃 오브젝트를 생성하고 요청을 위임해주는 식이다.
- 특별한 상황에서 타깃에 대한 접근권한을 제어하기 위해 사용할 수도 있다.
- 구조적으로 보면 프록시와 데코레이터 패턴은 유사하지만 프록시는 코드에 자신이 접근할 타깃 클래스 정보를 직접적으로 알아야한다.